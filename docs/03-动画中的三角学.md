本文将讲述一些 canvas 中三角学的应用，其中包括：

- 三角函数
- 旋转
- 波形
- 圆与椭圆
- 勾股定理
- 两点间距离

# 角

## 弧度与角度

在开始之前我们要先熟悉弧度与角度，因为在 JavaScript 自带的 Math 对象的三角函数方法均使用的是弧度制。

中学学过 `360°` 等于 `2π` 弧度，所以角度与弧度的转换公式为：

```
弧度 = 角度 * Math.PI / 180
角度 = 弧度 * 180 / Math.PI
```

## canvas 坐标系

canvas 画布中左上角为为 `(0, 0)`。如下图：

![](https://gw.alicdn.com/imgextra/i1/O1CN01cFpNJc1PdIYlBe5sX_!!6000000001863-55-tps-224-197.svg)

除了坐标系比较特殊外，其角度测量也有特点，即顺时针为正，逆时针为负，如下图：

![](https://gw.alicdn.com/imgextra/i1/O1CN013Kyw9Q1yRrDo7Matw_!!6000000006576-55-tps-224-283.svg)

## 三角函数

三角函数将直角三角形的内角和它的两个边的比值相关联，也可以等价地用与单位圆有关的各种线段的长度来定义。

![](https://gw.alicdn.com/imgextra/i1/O1CN01WHlUyc1QrmhixGATC_!!6000000002030-55-tps-209-121.svg)

### 正弦：对边比斜边

例如：30° 的正弦为 0.5

```js
console.log(Math.sin(30 * Math.PI / 180)) // 0.49999999999999994
```

不等于 0.5 的原因是 JavaScript 中浮点数存储，具体这里不做展开

同样 -30° 的正弦为 -0.5 如下

```js
console.log(Math.sin(-30 * Math.PI / 180)) // -0.49999999999999994
```

### 余弦：邻边比斜边

```js
console.log(Math.cos(30 * Math.PI / 180)) // 0.8660254037844387
console.log(Math.cos(60 * Math.PI / 180)) // 0.5000000000000001
```

### 正切：对边比邻边

![](https://gw.alicdn.com/imgextra/i4/O1CN01v3oYfF1nbyBn2pK2W_!!6000000005109-55-tps-136-121.svg)

![](https://gw.alicdn.com/imgextra/i3/O1CN01BXhytW1bC4PG8lBI5_!!6000000003428-55-tps-130-122.svg)

需要注意其正负的特性

```js
console.log(Math.tan(45 * Math.PI / 180)) // 0.9999999999999999
console.log(Math.tan(-45 * Math.PI / 180)) // -0.9999999999999999
```

### 反正弦与反余弦

简单来说就是正弦与余弦的逆运算，输入一个比率，得到对应的角的弧度

例如：

```js
console.log(Math.asin(1/2) * 180 / Math.PI) // 30.000000000000004
console.log(Math.acos(1/2) * 180 / Math.PI) // 60.00000000000001
```

### 反正切

![](https://gw.alicdn.com/imgextra/i3/O1CN01ziLXU71GreQnJPbHS_!!6000000000676-55-tps-245-203.svg)

反正切是正切的逆运算，给一个比率，得出对应的角的弧度

例如三角形 A 和 B 的反正切为：

```js
console.log(Math.atan(-1/-1) * 180 / Math.PI) // 45
console.log(Math.atan(1/1) * 180 / Math.PI) // 45
```

但此时我们无法区分这个反正切的值对应的角是三角形 A 还是 B。这就需要另一个可以算出方位角的反正切函数 `atan2`，其接受2个参数，对边的长度和邻边的长度，例如：

```js
console.log(Math.atan2(-1, -1) * 180 / Math.PI) // -135
console.log(Math.atan2(1, 1) * 180 / Math.PI) // 45
```

可以看出第一个结果为 -135°，恰好为三角形 A 的方位角。

# 旋转

复习了三角函数，接下来做一个实践。实现一个总是指向鼠标的箭头吧。

首先画一个箭头，创建一个 Arrow 类

```js
class Arrow {
  x: number

  y: number

  color: string

  rotation: number

  constructor() {
    this.x = 0
    this.y = 0
    this.color = '#42A5F5'
    this.rotation = 0
  }

  draw(context: CanvasRenderingContext2D) {
    context.save()
    context.translate(this.x, this.y)
    context.rotate(this.rotation)
    context.lineWidth = 2
    context.fillStyle = this.color
    context.beginPath()
    context.moveTo(-50, -25)
    context.lineTo(0, -25)
    context.lineTo(0, -50)
    context.lineTo(50, 0)
    context.lineTo(0, 50)
    context.lineTo(0, 25)
    context.lineTo(-50, 25)
    context.lineTo(-50, -25)
    context.closePath()
    context.fill()
    context.stroke()
    context.restore()
  }
}

export default Arrow
```

创建 <canvas> 标签，展示这个箭头

```html
<canvas id="mainCanvas" style="background-color: #fff;"></canvas>
```

把箭头放置在画布的中央

```js
import Arrow from '../common/Arrow'

const canvas: HTMLCanvasElement | null = document.querySelector('#mainCanvas')

if (canvas) {
  canvas.width = 800
  canvas.height = 400
  const context = canvas.getContext('2d')
  const arrow = new Arrow()
  arrow.x = canvas.width / 2
  arrow.y = canvas.height / 2
  if (context) {
    arrow.draw(context)
  }
}
```

看到效果如下：

![](https://gw.alicdn.com/imgextra/i3/O1CN01sWNZxi1l3V9ckkdgy_!!6000000004763-2-tps-1578-782.png)

监听鼠标移动，创建一个 util.ts 文件，增加鼠标位置的监听

```js
const captureMouse = (element: HTMLElement) => {
  const mouse: {
    x: number
    y: number
    event: MouseEvent | null
  } = {
    x: 0,
    y: 0,
    event: null,
  }
  const { offsetLeft, offsetTop } = element

  element.addEventListener('mousemove', (e) => {
    let x
    let y
    x = e.pageX
    y = e.pageY
    x -= offsetLeft
    y -= offsetTop
    mouse.x = x
    mouse.y = y
    mouse.event = e
  })
  return mouse
}

export { captureMouse }
```

再将鼠标位置的监听增加到 canvas 主逻辑上

```js
import Arrow from '../common/Arrow'
import { captureMouse } from '../common/utils'

const canvas: HTMLCanvasElement | null = document.querySelector('#mainCanvas')

if (canvas) {
  canvas.width = 800
  canvas.height = 400
  const context = canvas.getContext('2d')
  const arrow = new Arrow()
  arrow.x = canvas.width / 2
  arrow.y = canvas.height / 2

  const pos = captureMouse(canvas) // 监听鼠标位置

  if (context) {
    const drawFrame = () => {
      window.requestAnimationFrame(drawFrame) // 每帧执行
      context.clearRect(0, 0, canvas.width, canvas.height) // 清除画布内容
      if (pos.x && pos.y) {
        const dx = pos.x - arrow.x
        const dy = pos.y - arrow.y
        arrow.rotation = Math.atan2(dy, dx) // 这里计算出方位角
      }
      arrow.draw(context)
    }
    drawFrame()
  }
}
```

巧妙的使用了方位角反正切函数，效果如下：

![](https://gw.alicdn.com/imgextra/i1/O1CN01EsRvtO1rWFi9law2I_!!6000000005638-1-tps-787-358.gif)

# 波

# 圆与椭圆

# 勾股定理

## 两点间距离
