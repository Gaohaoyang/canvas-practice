本文将开始讲述动画编程的部分，会从基本的运动属性开始：速度、向量和加速度

- 速度
- 加速度

# 速度向量

速度向量指某个方向上的速度。这里包含速度的值和方向（既有大小，又有方向）。

任何一个速度向量又可以被分解为 x 方向和 y 方向。

![](https://gw.alicdn.com/imgextra/i1/O1CN01WPKEIm1RfFU3WNga3_!!6000000002138-2-tps-233-197.png)

接下来的示例中，我们会使用 vx 表示 x 轴上的速度向量，vy 表示 y 轴上的速度向量。

## 匀速直线运动

匀速直线运动是指运动快慢不变（即速度不变）、沿着直线的运动。在匀速直线运动中，路程与时间成正比，用公式 s=vt 计算。

这里复用《动画中的三角学》一文中创建的 Ball 类，进行小球的匀速直线运动示例

代码如下

```js
import stats from '../../common/stats'
import Ball from '../../common/Ball'

const canvas: HTMLCanvasElement | null = document.querySelector('#mainCanvas')

const vx = 10 // x 方向速度， 10 像素/s
const vy = 20 // y 方向速度， 20 像素/s
const x0 = 20 // 初始位置
const y0 = 20

if (canvas) {
  canvas.width = window.screen.width
  canvas.height = window.screen.height
  const context = canvas.getContext('2d')

  const ball = new Ball(10, '#1E88E5')
  if (context) {
    const drawFrame = (time: number) => {
      stats.begin()
      const timeInSeconds = time / 1000 // 将毫秒转为秒单位

      context.clearRect(0, 0, canvas.width, canvas.height)
      ball.x = vx * timeInSeconds + x0
      ball.y = vy * timeInSeconds + y0
      ball.draw(context)

      stats.end()
      window.requestAnimationFrame(drawFrame)
    }
    drawFrame(0)
  }
}
```

核心代码为

```js
ball.x = vx * timeInSeconds + x0
ball.y = vy * timeInSeconds + y0
```

效果如下

![](https://gw.alicdn.com/imgextra/i3/O1CN01MpcTv41Ul9QwSjb1d_!!6000000002557-1-tps-386-416.gif)

demo 链接 [https://gaohaoyang.github.io/canvas-practice/17-uniform-linear-motion/](https://gaohaoyang.github.io/canvas-practice/17-uniform-linear-motion/)

源码链接 [https://github.com/Gaohaoyang/canvas-practice/blob/main/src/17-uniform-linear-motion/index.ts](https://github.com/Gaohaoyang/canvas-practice/blob/main/src/17-uniform-linear-motion/index.ts)

上述是通过速度的分量 vx 和 vy 进行计算的，如果未知速度的分量，只知道小球延45度每秒10像素运动，该如何实现呢？这就用到了三角函数，不清楚三角函数的可以回顾之前的文章《动画中的三角学》。

![](https://gw.alicdn.com/imgextra/i2/O1CN01tpYtrv1rnCMsinvlZ_!!6000000005675-2-tps-133-133.png)

其分量为

```
vx = 10 * cos(45)
vy = 10 * sin(45)
```

所以完整代码如下

```js
import stats from '../common/stats'
import Ball from '../common/Ball'

const canvas: HTMLCanvasElement | null = document.querySelector('#mainCanvas')

const alpha = 45 // 角度 45 度
const v = 10 // 速度， 10 像素/s
const x0 = 20 // 初始位置
const y0 = 20

if (canvas) {
  canvas.width = window.screen.width
  canvas.height = window.screen.height
  const context = canvas.getContext('2d')

  const ball = new Ball(10, '#1E88E5')
  if (context) {
    const drawFrame = (time: number) => {
      stats.begin()
      const timeInSeconds = time / 1000 // 将毫秒转为秒单位

      context.clearRect(0, 0, canvas.width, canvas.height)
      ball.x = v * Math.cos((alpha * Math.PI) / 180) * timeInSeconds + x0
      ball.y = v * Math.sin((alpha * Math.PI) / 180) * timeInSeconds + y0
      ball.draw(context)

      stats.end()
      window.requestAnimationFrame(drawFrame)
    }
    drawFrame(0)
  }
}
```

![](https://gw.alicdn.com/imgextra/i1/O1CN01OP2dne1CPw06KjJUq_!!6000000000074-1-tps-386-416.gif)

demo 链接 [https://gaohaoyang.github.io/canvas-practice/18-uniform-linear-motion2/](https://gaohaoyang.github.io/canvas-practice/18-uniform-linear-motion2/)

源码链接 [https://github.com/Gaohaoyang/canvas-practice/blob/main/src/18-uniform-linear-motion2/index.ts](https://github.com/Gaohaoyang/canvas-practice/blob/main/src/18-uniform-linear-motion2/index.ts)

## 移动到点击位置

在《动画中的三角学》一文中，我们实现了总是指向鼠标的箭头，现在我们将其稍加改造，改为总是移动到点击位置。

```js
import stats from '../common/stats'
import Arrow from '../common/Arrow'

const canvas: HTMLCanvasElement | null = document.querySelector('#mainCanvas')

const v = 100 // 速度 10 像素/s

/**
 * 获取鼠标点击位置
 */
const getClickPos = (element: HTMLElement) => {
  const pos = {
    x: 0,
    y: 0,
  }
  element.addEventListener('click', (e: MouseEvent) => {
    pos.x = e.pageX
    pos.y = e.pageY
  })
  return pos
}

if (canvas) {
  canvas.width = window.screen.width
  canvas.height = window.screen.height
  const context = canvas.getContext('2d')

  const arrow = new Arrow()
  arrow.x = canvas.width / 2
  arrow.y = canvas.height / 2

  const mousePos = getClickPos(canvas)

  let then = 0
  if (context) {
    const drawFrame = (time: number) => {
      stats.begin()

      const timeInSeconds = time / 1000 // 将毫秒转为秒单位
      const deltaTimeInSeconds = timeInSeconds - then // 每帧的间隔时间，单位s
      then = timeInSeconds

      context.clearRect(0, 0, canvas.width, canvas.height)
      const dx = mousePos.x - arrow.x
      const dy = mousePos.y - arrow.y
      const angle = Math.atan2(dy, dx)

      arrow.x += v * Math.cos(angle) * deltaTimeInSeconds
      arrow.y += v * Math.sin(angle) * deltaTimeInSeconds
      arrow.rotation = angle

      arrow.draw(context)

      stats.end()
      window.requestAnimationFrame(drawFrame)
    }
    drawFrame(0)
  }
}
```

![](https://gw.alicdn.com/imgextra/i3/O1CN01gJ80VJ1rJQckivf2K_!!6000000005610-1-tps-386-416.gif)

demo 链接 [https://gaohaoyang.github.io/canvas-practice/19-arrow-to-tap/](https://gaohaoyang.github.io/canvas-practice/19-arrow-to-tap/)

源码链接 [https://github.com/Gaohaoyang/canvas-practice/blob/main/src/19-arrow-to-tap/index.ts](https://github.com/Gaohaoyang/canvas-practice/blob/main/src/19-arrow-to-tap/index.ts)

# 加速度

# 总结

匀速直线运动

```
s = v * t + s0 // 速度 乘 时间 加 初始位置
```

获取速度分量的方式

```
vx = 某个方向的速度 * cos(该方向的角度)
vy = 某个方向的速度 * sin(该方向的角度)

ball.x = v * Math.cos((alpha * Math.PI) / 180) * timeInSeconds + x0
ball.y = v * Math.sin((alpha * Math.PI) / 180) * timeInSeconds + y0
```
